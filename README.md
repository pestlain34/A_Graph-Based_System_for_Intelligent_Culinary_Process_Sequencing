Веб-приложение для построения оптимальной последовательности этапов рецептов. Выполняется путем представления каждого этапа узлом ациклического графа (DAG). Упорядочивание топологической сортировкой (алгоритм Кана).

Алгоритм строит полный план выполнения шагов с учетом зависимостей и делит задачи на активные (требующие ресурса - один шаг выполняется за раз) и пассивные (выполняются «фоново» без ограничения параллелизма). Сначала все шаги формализуются в виде ориентированного ациклического графа (шаги - вершины, зависимости - ребра). Для каждого шага рассчитывается его критическое время - максимальное суммарное время от данного шага до конца (аналог длины самого длинного пути из вершины). Это позволяет оценивать приоритеты.

Затем алгоритм выбирает начальный порядок активных шагов жадно: на каждом шаге берется доступный активный шаг с наибольшим критическим временем (greedy по величине «доделал - сделал») и таким образом строит ориентировочный порядок. После этого запускается точный перебор последовательностей активных шагов методом DFS с отсечением (branch-and-bound). При переборе шаг считается готовым к выполнению, если все его активные предшественники уже включены в последовательность, а пассивные предшественники либо выполнены ранее, либо могут выполняться параллельно.

В процессе DFS поддерживается два параметра: уже затраченное время elapsed (сумма времен выполненных активных шагов) и оценка нижней границы оставшегося времени - простая сумма времен еще не выполненных активных шагов. Если elapsed + rem >= best_time (где best_time - текущее лучшее известное время), ветвь отсекается, поскольку даже в оптимальном случае (без задержек) она не улучшит решение. Это отсечение безопасно: оно исходит из аддитивной оценки нижней границы (никакая другая параллельная работа не может укоротить время последовательного выполнения активных задач).

Когда перебраны все доступные порядки, для каждого полного порядка активных шагов строится окончательный план расписания (build_schedule_from_active_order): активные задачи выполняются последовательно в указанном порядке, а пассивные запускаются как можно раньше (по мере выполнения их предшественников). Итоговое время завершения (makespan) - максимум из времен окончания всех задач. Алгоритм выбирает последовательность с минимальным makespan.